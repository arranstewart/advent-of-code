
-- | Solution to advent of code 2015 problem, day 25
--
-- * see the problem at:  
--   https://adventofcode.com/2015/day/25 
--  
-- * see discussion at:  
--   https://www.reddit.com/r/adventofcode/comments/3y5jco/day_25_solutions/
--
-- * uses @arithmoi@ for modular exponentiation:
--   https://hackage.haskell.org/package/arithmoi 
--
-- If you have <https://www.haskellstack.org/ Stack> and 
-- and @arithmoi@ installed, you should be able to build with:
--
-- @
-- stack ghc -- --make -O2 snow-codes.hs
-- @

module Main (

  -- * pairing function
  
  -- | The function for looking up the /n/th code, given
  -- a @\<row,column\>@ pair is a  
  -- <https://en.wikipedia.org/wiki/Pairing_function pairing function> –
  -- it encodes two positive integers (the row and column) in
  -- a single positive integer (the result). (Or vice versa, since it's
  -- a bijection.)
  --
  -- @
  --     |  1   2   3   4   5   6  
  --  ---+---+---+---+---+---+---+
  --   1 |  1   3   6  10  15  21
  --   2 |  2   5   9  14  20
  --   3 |  4   8  13  19
  --   4 |  7  12  18
  --   5 | 11  17
  --   6 | 16
  -- @


    pair
  , showStartGrid

  -- * code calculation

  -- | Given a row and column, the 'pair' function tells us
  -- which number code we need – these two functions actually calculate it.
  --
  -- It turns out the /n/th code is a number of the form
  --  @a*(b^n)@ modulo @c@, where @a@, @b@ and @c@ are hard-coded
  -- numbers given in the problem text:   
  --
  -- @
  -- "The voice on the other end of the phone continues with how the codes are
  -- actually generated. The first code is 20151125. After that, each code is
  -- generated by taking the previous one, multiplying it by 252533, and then
  -- keeping the remainder from dividing that value by 33554393."
  -- @

  ,code
  ,code'modExp

  -- * main
  
  , main

) where

import Text.Printf
import Control.Monad
-- arithmoi
import Math.NumberTheory.Powers

-- | for positive integers (@x@, @y@), 
--   give the positive integer they can be encoded as. 
pair :: (Int,Int) -> Int
pair (x,y) = (x+y) * (x+y-1) `div` 2 - (y - 1)

-- | check, by visual inspection, that the pairing function 
-- is working ..
--
-- Prints the grid, up to @x=10@ and @y=10@,
-- produced by 'pair'.
showStartGrid :: IO ()
showStartGrid = do
  forM_ [1..10] $ \y -> do
    forM_ [1..10] $ \x -> do
      putStr $ printf "%4d" (pair (x,y))
    putStrLn ""


-- | "@code n@" returns the /n/th code for the weather machine.
-- 
-- This implementation is a simple recursive one – see 
--  'code'modExp' for a far faster one that uses modular
-- exponentiation.
--
-- Effectively, it is just calculating
--    @20151125*(252533^(n-1))@, modulo 33554393.
code :: Int -> Int
code n = 
  go n k1
  where
  k1 = 20151125

  go n last =
    if n == 1 
      then last
      else let next = (last * 252533) `mod` 33554393 
           in  go (n-1) next

fint :: (Integral a, Integral b) => a -> b
fint = fromIntegral

-- | @'code'modExp' n@ returns the /n/th code for the weather machine,
-- just as 'code' does, but uses the 
-- <https://hackage.haskell.org/package/arithmoi arithmoi> package's
-- 'powerMod' function, which is optimized to
-- perform 
-- <https://en.wikipedia.org/wiki/Modular_exponentiation modular exponentiation>
-- very quickly.
--
-- On my machine, solving Part 1 of the problem takes about 0.3 of a second
-- using 'code', but pretty much instantly (around 10 milliseconds)
-- using 'code'modExp'.
code'modExp :: Int -> Int
code'modExp n = 
    let e1 = myStart * (powerMod myBase (n-1) myMod)
    in  fint $ e1 `mod` myMod 
  where
  myStart = 20151125 
  myMod = 33554393
  myBase =  252533 


partA :: IO ()
partA = do
  let x = 3029
      y = 2947
      n = pair (x,y)
  print $ code'modExp n


-- From the reddit discussion thread.
--
-- "ixOf" is the pairing function, "part1" builds up a lazy list,
-- where each member of the list is the result of applying
--  "step" to the previous member ("step" being a step in
-- the modular exponentiation).
haoformayorsVersion :: Int -> Int -> Int
haoformayorsVersion a b = do
  let 
    ixOf (r, c) = ((n - 1) * (n - 2) `div` 2 + n - r - 1) where n = r + c
    step        = snd . (`divMod` 33554393) . (* 252533)
    part1       = iterate step 20151125 !! ixOf (a, b)
  part1    

main :: IO ()
main =
  partA




